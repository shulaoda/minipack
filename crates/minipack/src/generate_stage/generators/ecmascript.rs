use std::sync::Arc;

use crate::types::generator::{GenerateContext, GenerateOutput};

use minipack_common::{
  InstantiatedChunk, ModuleId, ModuleIdx, OutputFormat, RenderedModule, Source,
};
use minipack_error::BuildResult;
use minipack_utils::rayon::{IndexedParallelIterator, IntoParallelRefIterator, ParallelIterator};
use rustc_hash::FxHashMap;

use super::formats::{cjs::render_cjs, esm::render_esm};

pub type RenderedModuleSources = Vec<RenderedModuleSource>;

pub struct RenderedModuleSource {
  pub module_idx: ModuleIdx,
  pub module_id: ModuleId,
  pub exec_order: u32,
  pub sources: Option<Arc<[Box<dyn Source + Send + Sync>]>>,
}

impl RenderedModuleSource {
  pub fn new(
    module_idx: ModuleIdx,
    module_id: ModuleId,
    exec_order: u32,
    sources: Option<Arc<[Box<dyn Source + Send + Sync>]>>,
  ) -> Self {
    Self { module_idx, module_id, exec_order, sources }
  }
}
pub struct EcmaGenerator;

impl EcmaGenerator {
  pub async fn instantiate_chunk(ctx: &mut GenerateContext<'_>) -> BuildResult<GenerateOutput> {
    let mut rendered_modules = FxHashMap::default();
    let module_id_to_codegen_ret = std::mem::take(&mut ctx.module_id_to_codegen_ret);
    let rendered_module_sources = ctx
      .chunk
      .modules
      .par_iter()
      .zip(module_id_to_codegen_ret)
      .filter_map(|(id, codegen_ret)| {
        ctx.link_output.module_table[*id]
          .as_normal()
          .map(|m| (m, codegen_ret.expect("should have codegen_ret")))
      })
      .map(|(m, code)| {
        let sources = (!code.is_empty())
          .then_some(Arc::from([Box::new(code) as Box<dyn Source + Send + Sync>]));
        RenderedModuleSource::new(m.idx, m.id.clone(), m.exec_order, sources)
      })
      .collect::<Vec<_>>();

    rendered_module_sources.iter().for_each(|rendered_module_source| {
      let RenderedModuleSource { module_id, exec_order, sources, .. } = rendered_module_source;
      rendered_modules.insert(module_id.clone(), RenderedModule::new(sources.clone(), *exec_order));
    });

    let rendered_chunk =
      ctx.chunk.preliminary_filename.as_deref().expect("should have preliminary_filename").clone();

    let source_joiner = match ctx.options.format {
      OutputFormat::Esm => render_esm(ctx, &rendered_module_sources),
      OutputFormat::Cjs => render_cjs(ctx, &rendered_module_sources)?,
    };

    let content = source_joiner.join();

    // Here file path is generated by chunk file name template, it maybe including path segments.
    // So here need to read it's parent directory as file_dir.
    let file_path = ctx.options.cwd.as_path().join(&ctx.options.dir).join(
      ctx
        .chunk
        .preliminary_filename
        .as_deref()
        .expect("chunk file name should be generated before rendering")
        .as_str(),
    );
    let file_dir = file_path.parent().expect("chunk file name should have a parent");
    let preliminary_filename =
      ctx.chunk.preliminary_filename.clone().expect("should have preliminary filename");

    let instantiated_chunk = InstantiatedChunk {
      origin_chunk: ctx.chunk_idx,
      content,
      kind: rendered_chunk.into(),
      augment_chunk_hash: None,
      file_dir: file_dir.to_path_buf(),
      preliminary_filename,
    };

    Ok(GenerateOutput {
      chunks: vec![instantiated_chunk],
      warnings: std::mem::take(&mut ctx.warnings),
    })
  }
}
